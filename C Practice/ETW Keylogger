#include <windows.h>
#include <stdio.h>
#include <tchar.h>
#include <cstdlib>
#include <iostream>
#include <string>
#include <fstream>
#include <iterator>
#include <regex>

using namespace std;

        


void function(LPSTR cmd)
{
    STARTUPINFO info;
    PROCESS_INFORMATION processInfo;
    ZeroMemory(&info, sizeof(info));
    info.cb= sizeof( info );
    ZeroMemory(&processInfo, sizeof(processInfo));
    info.dwFlags= STARTF_USESHOWWINDOW;
    info.wShowWindow= SW_SHOWNORMAL;
    
    CreateProcess(
            NULL, 
            cmd,
            NULL, 
            NULL,
            FALSE,
            0,
            NULL,
            NULL,
            &info,
            &processInfo
            );
   //this will make the program pause until the window is closed - time = DWORD $Number (or "INFINITE" in this case)
    WaitForSingleObject( processInfo.hProcess, INFINITE );
    CloseHandle( processInfo.hProcess );
    CloseHandle( processInfo.hThread );
}
void shell(void)
{
       ShellExecute(
        NULL,
        "runas",
        "C://windows//notepad.exe",
        " C://test.txt",
        NULL,
        SW_SHOWNORMAL
        );
}

/* This works but only finds the first match
 * int filetest()
{
    string line;
    ifstream inp;
    ofstream out;
    regex pattern("08\\s00\\s00\\s00\\s\\d+");
    
    inp.open("C:\\regexpractice.txt");
    out.open("C:\\results.txt");   
    if (inp.is_open())
    {
        while(inp.good())
        {
            smatch result;
            getline(inp, line);                      
            regex_search(line, result, pattern);                         
            out << result.str() << endl;
            
        }
    }
    inp.close();
    out.close();
    return 0;
}
*/
int filetest()
{
    string line;
    ifstream inp;
    ofstream out;
    regex pattern("8000(.{2})");
    
    inp.open("C:\\results1.txt");
    out.open("C:\\text.txt");   
    if (inp.is_open())
    {
        while(inp.good())
        {
           
            getline(inp, line);
            copy(sregex_token_iterator(line.begin(), line.end(), pattern),
            sregex_token_iterator(),
            ostream_iterator<string>(out, "\n"));
       
            
            
            
        }
    }
    inp.close();
    out.close();
    return 0;
}


 int test()
{
//#define BUFFER_CAPACITY 512 ///512
    unsigned char x;
    ifstream data("C:\\trace_000001.etl", std::ios::binary);
    ofstream out("C:\\results1.txt");
    data >> std::noskipws;
    while(data >> x)
    {
        out << hex << (int)x;
    }
   

    return 0;
}

 /*
int test2()
{
    const char *filename = "C:\\trace_000001.etl";
    ifstream infile(filename, fstream::in);
    ofstream out("C:\\results1.txt", fstream::out);
    unsigned int a;
    infile >> hex >> a;
    out << hex << a;
}
  * /
/*char stringmatch(string x)
{
    //string regex_string = "(?<=08\\s00\\s00\\s00\\s)\\d+(?=\\s00)";
    regex pattern("(?<=08\\s00\\s00\\s00\\s)\\d+(?=\\s00)");
    //regex_iterator it(x.begin;(), x.end(), pattern);
    //regex_iterator it_end;
    while(it != it_end)
    {
        cout << *it << endl;
        ++it;
    }
          
}
*/
int main()
{   
    /* used these for testing*/
    //function("C://windows//notepad.exe \"C://test.txt\"",3000);
    //shell();  
    
    /*logman function, grayed out for now to test log parsing
     * function("C://windows//system32//logman.exe create trace -n \"usbtrace\" -o \"C://trace3.etl\" -nb \"128 640\" -bs \"128\"");
    function("C://windows//system32//logman.exe update trace -n \"usbtrace\" -p \"microsoft-windows-usb-usbport\"");
    function("C://windows//system32//logman.exe start -n usbtrace");
    Sleep(10000);
    function("C://windows//system32//logman.exe stop -n usbtrace");
    function("C://windows//system32//logman.exe delete -n usbtrace");
     * */
 
    test();
    filetest();
   
}
